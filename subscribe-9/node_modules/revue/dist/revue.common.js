'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var dotProp = _interopDefault(require('dot-prop'));

// to valid and match like `a as x.y.z`
var re = /^([\w\.-]+)\s+as\s+([\w\.-]+)$/i;

var isDev = process.env.NODE_ENV !== 'production';

function parseProp(prop) {
	// realProp: property name/path in your instance
	// storeProp: property name/path in Redux store
	var realProp = prop;
	var storeProp = prop;
	if (re.test(prop)) {
		var assign;
		(assign = prop.match(re), storeProp = assign[1], realProp = assign[2], assign);
	}
	return {storeProp: storeProp, realProp: realProp}
}

function deepProp(obj, path){
	return path.split('.').reduce(function (o, p) { return o[p]; }, obj);
}

/**
 * Bind reduxStore to Vue instance
 *
 * @param {Vue} Vue
 * @param {object} store - redux store
 */
function bindVue(Vue, store) {
	Vue.mixin({
		created: function created() {
			var this$1 = this;

			if (this._bindProps) {
				var handleChange = function () {
					this$1._bindProps.forEach(function (prop) {
						var storeProp = prop.storeProp;
						var realProp = prop.realProp;
						if (realProp && storeProp) {
							dotProp.set(this$1, realProp, deepProp(store.getState(), storeProp));
						}
					});
				};
				this._unsubscribe = store.subscribe(handleChange);
			}
		},
		beforeDestroy: function beforeDestroy() {
			if (this._unsubscribe) {
				this._unsubscribe();
			}
		}
	});
	Vue.prototype.$select = function (prop) {
		// realProp: property name/path in your instance
		// storeProp: property name/path in Redux store
		this._bindProps = this._bindProps || [];
		prop = parseProp(prop);
		this._bindProps.push(prop);
		return deepProp(store.getState(), prop.storeProp)
	};
}

var Revue = function Revue(Vue, reduxStore, reduxActions) {
	this.store = reduxStore;
	bindVue(Vue, this.store);
	if (reduxActions) {
		this.reduxActions = reduxActions;
	}
};

var prototypeAccessors = { state: {},actions: {} };
prototypeAccessors.state.get = function () {
	return this.store.getState()
};
prototypeAccessors.actions.get = function () {
	if (isDev && !this.reduxActions) {
		throw new Error('[Revue] Binding actions to Revue before calling them!')
	}
	return this.reduxActions
};
Revue.prototype.dispatch = function dispatch () {
		var args = [], len = arguments.length;
		while ( len-- ) args[ len ] = arguments[ len ];

	return (ref = this.store).dispatch.apply(ref, args)
		var ref;
};

Object.defineProperties( Revue.prototype, prototypeAccessors );

module.exports = Revue;
