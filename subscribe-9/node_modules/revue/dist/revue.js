(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.Revue = factory());
}(this, (function () { 'use strict';

var index$1 = function (x) {
	var type = typeof x;
	return x !== null && (type === 'object' || type === 'function');
};

var isObj = index$1;

function getPathSegments(path) {
	var pathArr = path.split('.');
	var parts = [];

	for (var i = 0; i < pathArr.length; i++) {
		var p = pathArr[i];

		while (p[p.length - 1] === '\\' && pathArr[i + 1] !== undefined) {
			p = p.slice(0, -1) + '.';
			p += pathArr[++i];
		}

		parts.push(p);
	}

	return parts;
}

var index = {
	get: function get(obj, path, value) {
		if (!isObj(obj) || typeof path !== 'string') {
			return obj;
		}

		var pathArr = getPathSegments(path);

		for (var i = 0; i < pathArr.length; i++) {
			if (!Object.prototype.propertyIsEnumerable.call(obj, pathArr[i])) {
				return value;
			}

			obj = obj[pathArr[i]];

			if (obj === undefined || obj === null) {
				// `obj` is either `undefined` or `null` so we want to stop the loop, and
				// if this is not the last bit of the path, and
				// if it did't return `undefined`
				// it would return `null` if `obj` is `null`
				// but we want `get({foo: null}, 'foo.bar')` to equal `undefined`, or the supplied value, not `null`
				if (i !== pathArr.length - 1) {
					return value;
				}

				break;
			}
		}

		return obj;
	},

	set: function set(obj, path, value) {
		if (!isObj(obj) || typeof path !== 'string') {
			return;
		}

		var pathArr = getPathSegments(path);

		for (var i = 0; i < pathArr.length; i++) {
			var p = pathArr[i];

			if (!isObj(obj[p])) {
				obj[p] = {};
			}

			if (i === pathArr.length - 1) {
				obj[p] = value;
			}

			obj = obj[p];
		}
	},

	delete: function delete$1(obj, path) {
		if (!isObj(obj) || typeof path !== 'string') {
			return;
		}

		var pathArr = getPathSegments(path);

		for (var i = 0; i < pathArr.length; i++) {
			var p = pathArr[i];

			if (i === pathArr.length - 1) {
				delete obj[p];
				return;
			}

			obj = obj[p];

			if (!isObj(obj)) {
				return;
			}
		}
	},

	has: function has(obj, path) {
		if (!isObj(obj) || typeof path !== 'string') {
			return false;
		}

		var pathArr = getPathSegments(path);

		for (var i = 0; i < pathArr.length; i++) {
			if (isObj(obj)) {
				if (!(pathArr[i] in obj)) {
					return false;
				}

				obj = obj[pathArr[i]];
			} else {
				return false;
			}
		}

		return true;
	}
};

// to valid and match like `a as x.y.z`
var re = /^([\w\.-]+)\s+as\s+([\w\.-]+)$/i;

var isDev = process.env.NODE_ENV !== 'production';

function parseProp(prop) {
	// realProp: property name/path in your instance
	// storeProp: property name/path in Redux store
	var realProp = prop;
	var storeProp = prop;
	if (re.test(prop)) {
		var assign;
		(assign = prop.match(re), storeProp = assign[1], realProp = assign[2], assign);
	}
	return {storeProp: storeProp, realProp: realProp}
}

function deepProp(obj, path){
	return path.split('.').reduce(function (o, p) { return o[p]; }, obj);
}

/**
 * Bind reduxStore to Vue instance
 *
 * @param {Vue} Vue
 * @param {object} store - redux store
 */
function bindVue(Vue, store) {
	Vue.mixin({
		created: function created() {
			var this$1 = this;

			if (this._bindProps) {
				var handleChange = function () {
					this$1._bindProps.forEach(function (prop) {
						var storeProp = prop.storeProp;
						var realProp = prop.realProp;
						if (realProp && storeProp) {
							index.set(this$1, realProp, deepProp(store.getState(), storeProp));
						}
					});
				};
				this._unsubscribe = store.subscribe(handleChange);
			}
		},
		beforeDestroy: function beforeDestroy() {
			if (this._unsubscribe) {
				this._unsubscribe();
			}
		}
	});
	Vue.prototype.$select = function (prop) {
		// realProp: property name/path in your instance
		// storeProp: property name/path in Redux store
		this._bindProps = this._bindProps || [];
		prop = parseProp(prop);
		this._bindProps.push(prop);
		return deepProp(store.getState(), prop.storeProp)
	};
}

var Revue = function Revue(Vue, reduxStore, reduxActions) {
	this.store = reduxStore;
	bindVue(Vue, this.store);
	if (reduxActions) {
		this.reduxActions = reduxActions;
	}
};

var prototypeAccessors = { state: {},actions: {} };
prototypeAccessors.state.get = function () {
	return this.store.getState()
};
prototypeAccessors.actions.get = function () {
	if (isDev && !this.reduxActions) {
		throw new Error('[Revue] Binding actions to Revue before calling them!')
	}
	return this.reduxActions
};
Revue.prototype.dispatch = function dispatch () {
		var args = [], len = arguments.length;
		while ( len-- ) args[ len ] = arguments[ len ];

	return (ref = this.store).dispatch.apply(ref, args)
		var ref;
};

Object.defineProperties( Revue.prototype, prototypeAccessors );

return Revue;

})));
